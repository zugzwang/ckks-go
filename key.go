package ckks

import (
	"math/big"

	"ckks/negacyclic"
)

// Key represents a key object, generated by an instance (see GenerateKey). It
// is the user's responsibility to handle Key.Secret securely.
type Key struct {
	Public     *PublicKey
	Secret     *SecretKey
	Evaluation *EvaluationKey
}

// PublicKey contains two polynomials. It is used for encryption of plaintext
// objects (see message.go).
type PublicKey struct {
	b, a *negacyclic.Polynomial
}

// SecretKey contains one polynomial with coefficients in {0, 1, -1}. It is
// used for decryption.
type SecretKey struct {
	s *negacyclic.Vector
}

// EvaluationKey is needed to homomorphically multiply two ciphertexts.
type EvaluationKey struct {
	b, a *negacyclic.Polynomial
}

// GenerateKey samples from the correct distributions and returns a Key object.
func (ins *Instance) GenerateKey() *Key {
	// Sample secret key
	dim := ins.N
	slice, err := negacyclic.HWT(dim, ins.Hamming)
	if err != nil {
		panic(err)
	}
	s := negacyclic.VectorFromSlice(slice)
	sk := SecretKey{
		s: s,
	}

	// Sample public key
	qL := ins.FirstModulus()
	a := negacyclic.PolynomialFromSlice(negacyclic.UniformMod(dim, qL))

	e := negacyclic.VectorFromSlice(negacyclic.DG(dim, ins.Sigma))
	b := negacyclic.MulSimple(a, s) // b: -as + e mod q_L
	b.Negate()
	b = negacyclic.Add(b, e)
	b.Mod(qL)
	pk := PublicKey{
		a: a,
		b: b,
	}

	// Sample evaluation key
	P := ins.pEv
	em := new(big.Int)
	em.Mul(P, qL) // em - evaluation modulus; P * q_L
	aBis := negacyclic.PolynomialFromSlice(negacyclic.UniformMod(dim, em))
	eBis := negacyclic.VectorFromSlice(negacyclic.DG(dim, ins.Sigma))
	bBis := negacyclic.MulSimple(aBis, s)
	bBis.Negate()
	bBis = negacyclic.Add(bBis, eBis)
	ps2 := negacyclic.MulSimple(s, s)
	ps2.Scale(P)
	bBis = negacyclic.Add(bBis, ps2) // b': -a's + e' + ps^2 mod p * q_L
	bBis.Mod(em)
	evk := EvaluationKey{
		a: aBis,
		b: bBis,
	}

	return &Key{
		Secret:     &sk,
		Public:     &pk,
		Evaluation: &evk,
	}
}

// Check verifies if the given key is consistent. A secret key `s` and a public
// key `(b,a)` match if and only if `b + as mod qL` is a vector with small
// coefficients. The evaluation key `(b', a')` matches if and only if `(b' + a's
// - Ps^2) mod P.qL` is a vector with small coefficients.
func (ins *Instance) Check(key *Key) error {
	// pk v.s sk
	modulus := ins.FirstModulus()
	small := negacyclic.MulSimple(key.Public.a, key.Secret.s)
	small = negacyclic.Add(small, key.Public.b)
	small.Mod(modulus)
	// evk v.s sk
	modulus.Mul(modulus, ins.pEv)
	small = negacyclic.MulSimple(key.Evaluation.a, key.Secret.s)
	small = negacyclic.Add(small, key.Evaluation.b)
	small.Mod(modulus)
	ps2 := negacyclic.MulSimple(key.Secret.s, key.Secret.s)
	for _, coeff := range ps2.Coeffs {
		coeff.Mul(coeff, ins.pEv)
		coeff.Neg(coeff)
	}
	small = negacyclic.Add(small, ps2)
	small.Mod(modulus)
	return nil
}
